import math
from qiskit import QuantumCircuit, QuantumRegister, AncillaRegister

def xor(a, b):
    """
    Parameters:
        - a,b are strings like '000', '001' of equal length.
    Output:
        The bitwise XOR of a and b.
    """
    return ''.join(['1' if z1 != z2 else '0' for (z1,z2) in zip(a,b)])

def generate_coset(representative, subgroup):
    """
    Parameters:
        - representative is the representative of the coset. It is assumed that
          representative has the same length as each bitstring in subgroup.
        - subgroup is the subgroup for which we want to generate a coset.
    Output:
        The coset of subgroup generated by representative as a frozenset of bitstrings.
    """
    return frozenset({ xor(representative, h) for h in subgroup })


def generate_group_by_order(order, strings=['0', '1']):
    """
    Parameters:
        - order is the size of the group of bitstrings to be generated.
        - strings is a technical parameter which you should never have to set yourself.
    Output:
        A list of all bitstrings in the group of bitstrings with specified order.
    """
    if order == 1:
        return strings

    zero_branch = generate_group_by_order(order - 1, strings=[s + '0' for s in strings])
    one_branch = generate_group_by_order(order - 1, strings=[s + '1' for s in strings])
    return zero_branch + one_branch

def generate_cosets_for_subgroup(group, subgroup):
    """
    Parameters:
        - group is a list of bitstrings resembling the group of bitstrings of a certain length.
          It is assumed that group is closed and that all bitstrings have the same length and 
          that there are no duplicate strings.
        - subgroup is the same as group, but for the subgroup for which we want to generate cosets.
    Output:
        A list of cosets, where each cosets is modelled as a list of bitstrings.
    """
    return list({ generate_coset(representative, subgroup) for representative in group })
        

def x_gate_where_bitstring_is_0(circuit, register, bitstring):
    """
    Parameters:
        - circuit is the quantum circuit currently being worked on
        - register is a main register of circuit, it is assumed to have as many qubits as bitstring has bits
        - bitstring
    This method applies an X-Gate on those qubits on register, where the corresponding bit in bitstring is a 0.
    """
    for s_index, bit in enumerate(bitstring):
            if bit == '0':
                circuit.x(register[register.size - s_index - 1])

class SimonOracle:
    def __init__(self, hidden_subgroup, ):
        """
        Parameters:
            - hidden_subgroup is a list of state vectors of the form ['000', '001']. This is supposed to be the entire hidden subgroup.
              It is assumed that the list of state vectors is non-empty.
        """
        self._hidden_subgroup = hidden_subgroup
        self._hidden_subgroup_order = len(self._hidden_subgroup)
        self._n = len(hidden_subgroup[0])

    def generate_default_circuit(self):
        """
        Generates a circuit implementing the oracle. If f is the oracle function, |x> is an n-qubit register and |y> is an m-qubit register,
        the circuit performs the calculation |x>|y> -> |x>|y XOR f(y)>.
        """
        input_register = QuantumRegister(self._n, 'x')
        output_register_size = math.floor(math.log2((2 ** self._n) // self._hidden_subgroup_order))
        output_register = QuantumRegister(output_register_size, 'y')
        ancilla_register = AncillaRegister(self._n - 2, 'anc')

        group = generate_group_by_order(self._n)
        cosets = generate_cosets_for_subgroup(group, self._hidden_subgroup)
        
        circuit = QuantumCircuit(input_register, output_register, ancilla_register)
        for c_index, coset in enumerate(cosets[1:]):
            for bitstring in coset:
                x_gate_where_bitstring_is_0(circuit, input_register, bitstring)

                output_value = format(c_index + 1, f'0{output_register_size}b')
                for o_index, bit in enumerate(output_value):
                    if bit == '1':
                        circuit.mcx(input_register, output_register[o_index], mode='v-chain', ancilla_qubits=ancilla_register)

                x_gate_where_bitstring_is_0(circuit, input_register, bitstring)
                
                circuit.barrier()

        return circuit




oracle = SimonOracle(['000'])
circuit = oracle.generate_default_circuit()
print(circuit)
